#! /usr/bin/python3

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test1.ui'
#
# Created by: PyQt5 UI code generator 5.15.3
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QTimer, Qt, QObject, QThread, pyqtSignal
from PyQt5.QtGui import QPalette, QColor

from pygame import mixer

import aubio
import numpy as num
import pyaudio
import sys
from threading import Thread, Event
import argparse
import random
import datetime
import time

NOTE_NAMES = 'C C# D D# E F F# G G# A A# B'.split()
NUM_NOTES = 12

# Track all the notes on a per-fret basis. <n>_NOTES will give you the note by
# fret.  0 is open, 1 is first fret, etc.
# ok, so there are more than 18 frets, but who's actually meedly meedlying up
# in the stratosphere with the 24th fret?
NUM_FRETS = 18
G_NOTES = 'G2 G#2 A2 A#2 B2 C3 C#3 D3 D#3 E3 F3 F#3 G3 G#3 A3 A#3 B3 C4 C#4'.split()
D_NOTES = 'D2 D#2 E2 F2 F#2 G2 G#2 A2 A#2 B2 C3 C#3 D3 D#3 E3 F3 F#3 G3 G#3'.split()
A_NOTES = 'A1 A#1 B1 C2 C#2 D2 D#2 E2 F2 F#2 G2 G#2 A2 A#2 B2 C3 C#3 D3 D#3'.split()
E_NOTES = 'E1 F1 F#1 G1 G#1 A1 A#1 B1 C2 C#2 D2 D#2 E2 F2 F#2 G2 G#2 A2 A#2'.split()
B_NOTES = 'B0 C1 C#1 D1 D#1 E1 F1 F#1 G1 G#1 A1 A#1 B1 C2 C#2 D2 D#2 E2 E#2'.split()
# String is mostly used to convert string number to name
STRING_LIST = 'E A D G'.split()
# String fret list is used to generate a random note on a random fret.
# so [0][3] will give you the E string, fret 3, or an G1
STRING_FRET_LIST = [E_NOTES, A_NOTES, D_NOTES, G_NOTES]
SHAPE_NAMES = ['major 7', 'dom 7', 'minor 7', 'm7 flat 5']

# The chord shape will give an offset from the root chord in [string][fret]
# format.  For example, a C major 7 will contain the root note (C), then a note
# one string up and one fret down (E) [1][-1], then a note one string up and
# two strings down from the root (G): [1][2], then a note two strings up and
# one string down (B): [2][1], and ending on a note two strings up and two
# strings down (C): [2][2]

MAJOR7_SHAPE = [[1,-1], [1,2], [2,1], [2,2]]
DOM7_SHAPE = [[1,-1], [1,2], [2,0], [2,2]]
MINOR7_SHAPE = [[1,-2], [1,2], [2,0], [2,2]]
MINOR7FLAT5_SHAPE = [[1,-2], [1,1], [2,0], [2,2]]
SHAPE_LIST = [MAJOR7_SHAPE, DOM7_SHAPE, MINOR7_SHAPE, MINOR7FLAT5_SHAPE]
#I hate the way I did the above, so trying something new for Nashville

# For major: 2 2 1 2 2 2 1
#     minor: 2 1 2 2 1 2 2
#     dim:   1 2 1 2 1 2 1
MAJOR_SCALE_IDX = [2, 2, 1, 2, 2, 2, 1]
MINOR_SCALE_IDX = [2, 1, 2, 2, 1, 2, 2]
DIM_SCALE_IDX = [1, 2, 1, 2, 1, 2, 1]

#whole whole half whole whole whole half
SCALE_IDX = [2, 2, 1, 2, 2, 2, 1]
#major, minor, minor, major, major, minor, dimninished, major
NASH_SHAPE_IDX = ['major 7',
                  'minor 7',
                  'minor 7',
                  'major 7',
                  'major 7',
                  'minor 7',
                  'dom 7',
                  'major 7']

WRONG_SOUND = 'custWrong.ogg'
RIGHT_SOUND = 'custRight.ogg'
CLICK_SOUND = 'click.wav'
HI_CLICK_SOUND = 'hiClick.ogg'
LO_CLICK_SOUND = 'loClick.ogg'

ROBOT = """
~~~~~~~~~~BASSBOT~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++-----------------------------|---------------------(x)-------+--------------++
||  ,-.         \\.===./        |                     |         |     ( )      ||
||--o  |:---|---| n n |--------|------------#(x)-----|---------|--------------||
||    /     |)   \\_`_/         |    (x)      |       |         |              ||
||---/---------.=(+++)=.-----(x)----|--------|-----------------|--------------||
||  /    |  o="  (___)  "=o         |        |                 |              ||
||-------|)------|_|_|--------------|--------------------------|--------------||
||               /_|_\\                                         |              ||
++-------------------------------------------------------------+--------------++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"""

# some functions I found from a ukelele tuner app, all of which are based on
# https://newt.phys.unsw.edu.au/jw/notes.html
# These are used to convert frequencies to midi numbers and note names
def freq_to_number(f): return 69 + 12*num.log2(f/440.0)
def number_to_freq(n): return 440 * 2.0**((n-69)/12.0)
def note_name(n): return NOTE_NAMES[n % 12] + str(int(n/12 - 1))

# Some constants for setting the PyAudio capture and aubio note detection
# parameters
BUFFER_SIZE             = 4096
CHANNELS                = 1
FORMAT                  = pyaudio.paFloat32
METHOD                  = "default"
SAMPLE_RATE             = 44100
HOP_SIZE                = BUFFER_SIZE//2
PERIOD_SIZE_IN_FRAME    = HOP_SIZE

# Given a note, ex "C", return its idx in NOTE_NAMES
def getNoteIdx(note):
    return NOTE_NAMES.index(note)

# Takes in note index from NOTE_NAME, adds toAdd, and wraps around if
# result is more than 11
def addNotes(note, toAdd):
    return (note + toAdd) % 12

# Given a root, ex "C", a note, ex 3, and a scale list, ex MAJOR_SCALE_IDX,
# return the note, ex "E" found at position <note> of that scale
def getNoteOfScale(root, note, scaleList):
    rootIdx = getNoteIdx(root)
    offset = sum(scaleList[0:(note - 1)])
    offset = addNotes(rootIdx, offset)
    return NOTE_NAMES[offset]

# Given a root, ex "C", and a scale list, ex MAJOR_SCALE_IDX, return a list of
# strings representing the 1-3-5 arpeggio
def getArpeggio(note, scaleList, arpList):
    noteIdx = getNoteIdx(note)
    retVal = []
    for index in arpList:
        retVal.append(getNoteOfScale(note, index, scaleList))
    return retVal

# Given a key, ex "C", and a Nashville number, get the arpeggio
def getArpeggioFromScale(key, number, arpList = [1,3,5,3,1]):
    chordType = NASH_SHAPE_IDX[number - 1]
    root = getNoteOfScale(key, number, MAJOR_SCALE_IDX)
    print("  " + root + " " + chordType)
    if chordType == 'major 7':
        return getArpeggio(root, MAJOR_SCALE_IDX, arpList)
    elif chordType == 'minor 7':
        return getArpeggio(root, MINOR_SCALE_IDX, arpList)
    elif chordType == 'dom 7':
        return getArpeggio(root, DIM_SCALE_IDX, arpList)
    else:
        print("unknown chord type: " + chordType)
        return ['']

class sessionInfo:
    """Track performance statics through playing"""
    numRight = 0
    numWrong = 0
    timeList = ''
    level = 0

    def __init__(self, level):
        self.numRight = 0
        self.numWrong = 0
        self.timeList = ''
        self.level = level

class AudioHandler:
    """Set up mic input, take samples when tick is called, provide freq and vol"""

    def __init__(self):
        print("1")
         # Initiating PyAudio object.14
        pA = pyaudio.PyAudio()
        # Open the microphone stream.
        print("2")
        self.mic = pA.open(format=FORMAT, channels=CHANNELS,
                rate=SAMPLE_RATE, input=True,
                frames_per_buffer=PERIOD_SIZE_IN_FRAME)

        print("3")
        # Initiating Aubio's pitch detection object.
        self.pDetection = aubio.pitch(METHOD, BUFFER_SIZE,
            HOP_SIZE, SAMPLE_RATE)
        # Set unit.
        self.pDetection.set_unit("Hz")
        # Frequency under -40 dB will considered
        # as a silence.
        self.pDetection.set_silence(-50)

    def processAudio(self):
        # Always listening to the microphone.
        data = self.mic.read(PERIOD_SIZE_IN_FRAME)
        # Convert into number that Aubio understand.
        samples = num.fromstring(data,
            dtype=aubio.float_type)
        # Finally get the pitch.
        pitch = self.pDetection(samples)[0]
        # Compute the energy (volume)
        # of the current frame.
        volume = num.sum(samples**2)/len(samples)
        return pitch, volume

class levelConfig():
    evaluateFxn = 0

class freePlay():
    """Exercise for playing in the right key for the right amount of time"""
    def getInstructions(self):
        if self.level == 1:
            ret = "Level 1\n"
            ret += "\tPlay any notes in the listed chord's arepggio for 2 bars,\n"
            ret += "\tthen move to the next chord.\n\n"
            ret += "Start the metronome to begin."
            return ret
        elif self.level == 2:
            ret = "Level 2\n"
            ret += "\tPlay any notes in the listed chord's scale for 2 bars,\n"
            ret += "\tthen move to the next chord.\n\n"
            ret += "Start the metronome to begin."
            return ret
        else:
            return "There is no cow level"

    def __init__(self, level = 1, lastNote = ''):
        self.level = level
        self.currentChord = ''
        self.chordString = ''
        self.chordList = []
        self.chordIndex = -1
        self.currentValid = []
        self.ignoreNote = ''
        self.rightSound = mixer.Sound(RIGHT_SOUND)
        self.wrongSound = mixer.Sound(WRONG_SOUND)

        self.setNewGoal()
        self.status = ''

    def advanceChord(self):
        self.chordIndex += 1
        if self.chordIndex >= len(self.chordList):
            self.chordIndex = 0
        self.updateSecondaryGoal()
        self.currentChord = self.chordList[self.chordIndex]
        if self.level == 1:
            self.getArpeggios(self.currentChord)
        else:
            self.getScales(self.currentChord)

    def set_volume(self, volume):
        self.rightSound.set_volume(volume)
        self.wrongSound.set_volume(volume)

    def getStatus(self):
        return self.status

    def getGoal(self):
        return self.goal

    def getSecondaryGoal(self):
        return self.secondaryGoal

################################################################################
# M = Major 7th, print "^7" snince we have no triangle
# D = Dominant 7th, print 7
# m = minor 7th, print m7
# b = minor 7th flat 5, print m7b5
#
# When chord is listed, all octaves of chord are acceptable (no hi/mid/lo)
################################################################################

    def updateSecondaryGoal(self):
        if (self.chordIndex >= 0):
            self.secondaryGoal = "................."
            for i in range(self.chordIndex):
                self.secondaryGoal += "............."
        else:
            self.secondaryGoal = "......"
        self.secondaryGoal += "*"


    def setNewGoal(self):
        #hard coding for now... eventually, we figure out how to random
        self.chordList = ["CM", "Em", "FM", "GD"]
        self.chordIndex = -1
        self.currentChord = self.chordList[0]
        if self.level == 1:
            self.getArpeggios(self.currentChord)
        else:
            self.getScales(self.currentChord)

        self.chordString = ''
        for chord in self.chordList:
            # first grab the note
            self.chordString += chord[0]

            #then get the human readable symbol
            self.chordString += self.readableKey(chord[1]) + str("......")

        self.goal = "Play:......" + self.chordString
        self.updateSecondaryGoal()

    def readableKey(self, keyCode):
        if keyCode == "M":
            return "^7"
        elif keyCode == "D":
            return " 7"
        elif keyCode == "m":
            return "m7"
        elif keyCode == "b":
            return "m7b5"
        else:
            return "ERRRRROR!"

    # Set the current Valid list based on the current root chord.
    # Root chord will be in the format CM, CD, Cm, Cb
    def getArpeggios(self, root):
        #Major:
        # start with NOTE_NAMES, determine where root is.
        # marjor arpeggio is 1 3 5 7 8
        # indeces for scale: 0 2 4 5 7 9 11 12
        #   whole whole half whole whole whole half
        #   scale list will be rootIdx, rootIdx + 2, +4, +5, +7, +9, +11
        #   arpeggio list will be rootIdx, +4, +7, +11
        noteName = root[:-1]
        keyCode = root[-1]
        rootIdx = getNoteIdx(noteName)

        print("rootidx: " + str(rootIdx))

        self.currentValid = [noteName]
        if keyCode == "M":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 4)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 7)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 11)]
        elif keyCode == "D":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 4)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 7)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 10)]
        elif keyCode == "m":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 3)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 7)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 10)]
        elif keyCode == "b":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 3)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 6)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 10)]
        else:
            print("Error in getting arpeggios!!")

    # Set the current Valid list based on the current root chord.
    # Root chord will be in the format CM, CD, Cm, Cb
    def getScales(self, root):
        # Need to figure out all the options for this fella
        noteName = root[:-1]
        keyCode = root[-1]
        rootIdx = getNoteIdx(noteName)

        self.currentValid = [noteName]
        if keyCode == "M":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 2)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 4)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 5)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 7)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 9)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 11)]
        elif keyCode == "D":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 2)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 4)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 5)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 7)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 9)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 10)]
        elif keyCode == "m":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 2)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 3)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 5)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 7)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 9)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 10)]
        elif keyCode == "b":
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 2)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 3)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 5)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 6)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 9)]
            self.currentValid += NOTE_NAMES[addNotes(rootIdx, 10)]
        else:
            print("Error in getting scale notes!")

    # return True if display needs to be updated based on evaluation
    def evaluateNote(self, playedNote):
        # if this is a note we're ignoring, do nothing
        if (playedNote == self.ignoreNote):
            return False

        # if this is a mute note, clear the ignore list and do nothing
        if playedNote == 'none':
            self.ignoreNote = playedNote
            return False

        self.ignoreNote = playedNote
        playedNote = playedNote[:-1]
        root = playedNote[:-1]
        goodNote = False
        for note in self.currentValid:
            if note == playedNote:
                self.status = "Correct!"
                return True

        # If we are here, then a note is played that is not in the valid list
        self.status = "Out of key!  heard " + str(playedNote) + "\n"
        self.status += "expected one of: " + str(self.currentValid)
        self.wrongSound.play()
        return True

class nashville():
    """Handle instructions, goals, and evaluations for Nashville exercises"""
    def getInstructions(self):
        if self.level == 1:
            return "Level 1: Play 1-3-5 of each chord in the key of Cmaj"
        elif self.level == 2:
            return "Level 2: Play the 1-3-5 on a random chord in the key of Cmaj"
        elif self.level == 3:
            return "Level 3: Play 1-3-5 of each chord in a random major key"
        elif self.level == 4:
            return "Level 4: Play 1-3-5 of a random chord in a random major key"
        elif self.level == 5:
            return "Level 5: Pizza time!"
        else:
            print("DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!")
            return "DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!"

    def __init__(self, level = 1, lastNote = ''):
        self.level = level
        self.toPlay = lastNote
        self.ignoreNote = lastNote
        self.numRight = 0
        self.numWrong = 0
        self.rightSound = mixer.Sound(RIGHT_SOUND)
        self.wrongSound = mixer.Sound(WRONG_SOUND)

        self.chordTones = []
        for i in range(5):
            self.chordTones.append('')
        self.noteIdx = 0
        self.numberIdx = 0

        self.setNewGoal()
        self.status = ''

    def set_volume(self, volume):
        self.rightSound.set_volume(volume)
        self.wrongSound.set_volume(volume)

    def getStatus(self):
        return self.status

    def getSecondaryGoal(self):
        return self.secondaryGoal

    def getGoal(self):
        print("curr goal: " + self.goal)
        return self.goal

    def setNewGoal(self):
        self.key = ''
        self.secondaryGoal = ''
        self.order = [1, 3, 5, 3, 1]
        if self.level == 1:
            self.key = 'C'
            self.numbers = [1, 2, 3, 4, 5, 6, 7, 8]
        elif self.level == 2:
            self.key = 'C'
            self.numbers = [1 + random.randrange(7)]
        elif self.level == 3:
            self.key = NOTE_NAMES[random.randrange(12)]
            self.numbers = [1, 2, 3, 4, 5, 6, 7, 8]
        elif self.level == 4:
            self.key = NOTE_NAMES[random.randrange(12)]
            self.numbers = [1 + random.randrange(7)]
        elif self.level == 5:
            print("PIZZA PIZZA")

        self.goal = "Key of: " + self.key + "\n"
        self.goal += "Play the " + str(self.numbers[0])

        self.secondaryGoal += "Order: "
        self.secondaryGoal += str(self.order[0]) + " "
        self.noteIdx = 0;

        self.numIdx = 0
        currentChordType = NASH_SHAPE_IDX[self.numbers[self.numIdx]-1]
        self.currentNumber = self.numbers[self.numIdx]
        self.currentArp = getArpeggioFromScale(self.key, self.currentNumber)
        self.arpIdx = 0

    def getArpFromIdx(self, arpIdx):
        if arpIdx == 0:
            return 1
        elif arpIdx == 1:
            return 3
        elif arpIdx == 2:
            return 5
        elif arpIdx == 3:
            return 3
        elif arpIdx == 4:
            return 1
        return 9999

    def evaluateNote(self, playedNote):
        # if this is a note we're ignoring, do nothing
        if (playedNote == self.ignoreNote):
            return False

        # if this is a mute note, clear the ignore list and do nothing
        if playedNote == 'none':
            self.ignoreNote = playedNote
            return False

        self.ignoreNote = playedNote
        # Strip the number from the end of the ntoe
        playedNote = playedNote[:-1]

        self.toPlay = self.currentArp[self.arpIdx]
        print("toPlay: " + str(self.toPlay))

        if playedNote == self.toPlay:
            self.numRight += 1
            print("correct on idx" + str(self.arpIdx))
            self.arpIdx += 1

            if self.arpIdx >= len(self.currentArp):
                # If that was the last note in the arpeggio, move to the next
                # number
                print("arp for note " + str(self.currentNumber) + " complete")
                self.numIdx += 1
                if self.numIdx >= len(self.numbers):
                    # If that was the last number, exercise is done
                    print("exercise complete!")
                    self.setNewGoal()
                    self.status = ""
                    self.rightSound.play()
                    return True
                else:
                    # Otherwise, reset arp idx and move to the next number
                    self.rightSound.play()
                    self.arpIdx = 0
                    currentChordType = NASH_SHAPE_IDX[self.numbers[self.numIdx]-1]
                    self.currentNumber = self.numbers[self.numIdx]
                    if self.numIdx == 7:
                        self.order = [1, 3, 5, 7, 8]
                        self.currentArp = getArpeggioFromScale(self.key, self.currentNumber, self.order)
                    else:
                        self.currentArp = getArpeggioFromScale(self.key, self.currentNumber)
                    self.arpIdx = 0
                    self.goal += " " + str(self.currentNumber)
                    self.secondaryGoal = "Order: 1"
                    return True
            else:
                # If that was not the last note in the arpeggio, move to next
                self.secondaryGoal += str(self.order[self.arpIdx]) + " "
                print("update secondary goal?")
                return True
        else:
            print("wrongzo!")
            print("   expected " + str(self.toPlay))
            print("   heard " + str(playedNote))

            self.numWrong += 1
            #self.status = str(self.getArpFromIdx(self.order[self.noteIdx])) + " WRONG!\n"
            #self.status += str("expected " + str(self.toPlay) + ", heard " + str(playedNote))
            self.wrongSound.play()
            return True

class chordFinder():
    """Handle instructions, goals, and evaluations for chordFinder exercises"""
    def getInstructions(self):
        if self.level == 1:
            return "Level 1: Play a random chord shape arpeggio for a middle C"
        elif self.level == 2:
            return "Level 2: Play a random chord shape for a random root"
        elif self.level == 3:
            return "Level 3: Play a major 7 arpeggio for a middle C in a random order"
        elif self.level == 4:
            return "Level 4: Play a random chord shape for a middle C in a random order"
        elif self.level == 5:
            return "Level 5: Play a random chord shape for a random root in a random order"
        else:
            print("DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!")
            return "DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!"

    def __init__(self, level = 1, lastNote = ''):
        self.level = level
        self.toPlay = lastNote
        self.ignoreNote = lastNote
        self.numRight = 0
        self.numWrong = 0
        self.rightSound = mixer.Sound(RIGHT_SOUND)
        self.wrongSound = mixer.Sound(WRONG_SOUND)

        self.chordTones = []
        for i in range(5):
            self.chordTones.append('')
        self.order = []
        self.noteIdx = 0

        self.setNewGoal()
        self.status = ''

    def set_volume(self, volume):
        self.rightSound.set_volume(volume)
        self.wrongSound.set_volume(volume)

    def getStatus(self):
        return self.status

    def getSecondaryGoal(self):
        return self.secondaryGoal

    def getGoal(self):
        return self.goal

    def getArpFromIdx(self, arpNum):
        if arpNum == 0:
            return 1
        elif arpNum == 1:
            return 3
        elif arpNum == 2:
            return 5
        elif arpNum == 3:
            return 7
        elif arpNum == 4:
            return 8
        else:
            return 0

    def setNewGoal(self):
        string = 0
        fret = 0
        self.secondaryGoal = ''
        if self.level == 1:
            string = 0
            fret = 8
            self.order = [0, 1, 2, 3, 4, 3, 2, 1, 0]
        elif self.level == 2:
            # Must be string 0:1
            # Must be fret 2:12, though 12th fret limit is a bit artificial
            string = random.randrange(2)
            fret = 2 + random.randrange(11)
            self.order = [0, 1, 2, 3, 4, 3, 2, 1, 0]
        elif self.level == 3:
            string = 0
            fret = 8
            self.order = [0, 1, 2, 3, 4]
            random.shuffle(self.order)
        elif self.level == 4:
            string = 0
            fret = 8
            self.order = [0, 1, 2, 3, 4]
            random.shuffle(self.order)
        elif self.level == 5:
            string = random.randrange(2)
            fret = 2 + random.randrange(11)
            order = [0, 1, 2, 3, 4]
            random.shuffle(self.order)

        orderString = ''
        for i in self.order:
            orderString += str(self.getArpFromIdx(i)) + " "

        # hi/lo/mid convention:
        # low is anything from C1 to B1.  Mid is anything from C2 to B2.  High is
        # anything from C3 to B3.  C4 and C#4 are the devil and don't exist.
        # I'm not super happy with this, but... I can't think of a better way to do
        # it, especially when we expand to support 5 string basses later
        # While we're at it, lets strip the number off the chord name as well.
        chordRoot = STRING_FRET_LIST[string][fret]
        if chordRoot[-1] == '1':
            prefix = 'low '
            chordRoot = chordRoot[:-1]
        elif chordRoot[-1] == '2':
            prefix = 'mid '
            chordRoot = chordRoot[:-1]
        else:
            prefix = 'high '
            chordRoot = chordRoot[:-1]

        # shape selection
        if self.level == 3:
            shape_num = 0
        else:
            shape_num = random.randrange(4)
        shape = SHAPE_LIST[shape_num]

        self.chordTones[0] = STRING_FRET_LIST[string][fret]
        for i in range(1,5):
            self.chordTones[i] = STRING_FRET_LIST[string+shape[i-1][0]][fret+shape[i-1][1]]

        print(SHAPE_NAMES[shape_num] + " " + prefix + chordRoot)
        self.goal = prefix + chordRoot + " " + SHAPE_NAMES[shape_num]
        if (self.level >= 3):
            print("order: " + orderString)
            self.goal += "\norder: " + orderString

        self.secondaryGoal += "play: "
        self.secondaryGoal += str(self.getArpFromIdx(self.order[0])) + " "
        self.noteIdx = 0;

    def evaluateNote(self, playedNote):
        # if this is a note we're ignoring, do nothing
        if (playedNote == self.ignoreNote):
            return False

        # if this is a mute note, clear the ignore list and do nothing
        if playedNote == 'none':
            self.ignoreNote = playedNote
            return False

        self.toPlay = self.chordTones[self.order[self.noteIdx]]
        self.ignoreNote = playedNote

        if playedNote == self.toPlay:
            self.numRight += 1
            print("correct on " + str(self.getArpFromIdx(self.order[self.noteIdx])))

            if self.noteIdx >= len(self.order) -1:
                self.setNewGoal()
                self.status = ""
                print("Exercise complete!  Next note!")
                self.rightSound.play()
                return True
            else:
                self.noteIdx += 1
                self.secondaryGoal += str(self.getArpFromIdx(self.order[self.noteIdx])) + " "
                return True
        else:
            print("wrongzo!")
            print("   expected " + str(self.toPlay))
            print("   heard " + str(playedNote))

            self.numWrong += 1
            self.status = str(self.getArpFromIdx(self.order[self.noteIdx])) + " WRONG!\n"
            self.status += str("expected " + str(self.toPlay) + ", heard " + str(playedNote))
            self.wrongSound.play()
            return True

class fretFinder():
    """Handle instructions, goals, and evaluations for fretFinder exercises"""
    def getInstructions(self):
        if self.level == 1:
            return "Level 1: Play the string listed!"
        elif self.level == 2:
            retVal = "Level 2: Play the note listed!\n"
            return retVal + "  The answer will always be on one of the first 4 frets"
        elif self.level == 3:
            retVal = "Level 3: Play the note listed!"
            return retVal + "  ... but we're sticking below 12 frets"
        elif self.level == 4:
            retVal = "Level 4: Play the note listed!"
            return retVal + "  ... but we're sticking below " + str(NUM_FRETS) + " frets"
        else:
            print("DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!")
            return "DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!"

    def setNewGoal(self):
        while self.toPlay == self.ignoreNote:
            # Select a random string, 1-4
            string = random.randrange(4)

            # Select the fret for that string
            if (self.level == 1):
                fret = 0
                prefix = ''
            elif (self.level == 2):
                fret = random.randrange(5)
                prefix = ''
            elif (self.level == 3):
                fret = random.randrange(13)
                # Any mode with fret 12 or higher in play needs a high/low prefix to
                # differentiate between open string and the 12th+ fret
                if fret >= 12:
                    prefix = 'high '
                else:
                    prefix = 'low '
            elif (self.level == 4):
                fret = random.randrange(NUM_FRETS)
                if fret >= 12:
                    prefix = 'high '
                else:
                    prefix = 'low '
            else:
                print("dev made an oops- unknown level:" + str(self.level))
                return 0

            self.toPlay = STRING_FRET_LIST[string][fret]

        self.goal = STRING_LIST[string] + " string: " + prefix + self.toPlay

    def __init__(self, level = 1, lastNote = ''):
        self.level = level
        self.toPlay = lastNote
        self.ignoreNote = lastNote
        self.numRight = 0
        self.numWrong = 0
        self.rightSound = mixer.Sound(RIGHT_SOUND)
        self.wrongSound = mixer.Sound(WRONG_SOUND)

        self.secondaryGoal = ''
        self.setNewGoal()
        self.status = ''

    def set_volume(self, volume):
        self.rightSound.set_volume(volume)
        self.wrongSound.set_volume(volume)

    def getSecondaryGoal(self):
        return self.secondaryGoal

    def getStatus(self):
        return self.status

    def getGoal(self):
        return self.goal

    def evaluateNote(self, playedNote):
        # if this is a note we're ignoring, do nothing
        if (playedNote == self.ignoreNote):
            return False

        # if this is a mute note, clear the ignore list and do nothing
        if playedNote == 'none':
            self.ignoreNote = playedNote
            return False

        if playedNote == self.toPlay:
            self.numRight += 1
            print("correct!  played " + str(playedNote))
            self.ignoreNote = playedNote
            self.setNewGoal()
            self.status = ''
            self.rightSound.play()
            return True
        else:
            print("wrongzo!")
            print("   expected " + str(self.toPlay))
            print("   heard " + str(playedNote))
            self.ignoreNote = playedNote
            self.numWrong += 1

            self.status = "WRONG!\n"
            self.status += str("expected " + str(self.toPlay) + ", heard " + str(playedNote))
            self.wrongSound.play()
            return True

class Worker (QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(str)
    tuning = pyqtSignal(float)
    confidenceLevel = 2

    def run(self):
        print("testing")
        self.aHandler = AudioHandler()
        self.resultList = []
        while True:
            self.sampleNote()
        self.finished.emit()

    def sampleNote(self):
        result = self.aHandler.processAudio()
        pitch = result[0]
        volume = result[1]
        # Get note number and nearest note
        if (pitch == 0.0):
            name = "none"
        else:
            n = freq_to_number(pitch)
            n0 = int(round(n))
            name = note_name(n0)
            tune = n - n0
            self.tuning.emit(n-n0)

        # Format the volume output so it only
        # displays at most six numbers behind 0.
        volume = "{:6f}".format(volume)
        # Finally print the pitch and the volume.
        # print(name + " " + str(pitch) + " " + str(volume))
        # if we have confidenceLevel matches in a row, return this result
        self.resultList.insert(0, name)
        if len(self.resultList) >= self.confidenceLevel:
            # Count the number of entires in the list.  If same as length, then
            # the list all matches and we have hit enough confidence to return
            # a note value. Otherwise, pop the last entry and continue
            if (self.resultList.count(name) == len(self.resultList)):
                self.progress.emit(name)
                self.resultList = []
            else:
                self.resultList.pop()

################################################################################
# THIS IS AUTOGENERATED BY PYUIC5!!!
# DO NOT MAKE ANY CHANGES TO THIS BLOCK!!
# If you want to tie signals to these widgets, change their init params, add
# or remove, etc etc etc use Qt Designer and make them to the .ui file.
# Tieing signals, starting timers, etc should be done below the
# END PYUIC5 SECTION section.
################################################################################
class Ui_BassBot(object):
    def setupUi(self, BassBot):
        BassBot.setObjectName("BassBot")
        BassBot.resize(987, 417)
        self.centralwidget = QtWidgets.QWidget(BassBot)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(31, 20, 121, 191))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.ExerciseLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.ExerciseLayout.setContentsMargins(0, 0, 0, 0)
        self.ExerciseLayout.setObjectName("ExerciseLayout")
        self.exerciseRadioTuner = QtWidgets.QRadioButton(self.verticalLayoutWidget)
        self.exerciseRadioTuner.setObjectName("exerciseRadioTuner")
        self.ExerciseLayout.addWidget(self.exerciseRadioTuner)
        self.exerciseRadioFrets = QtWidgets.QRadioButton(self.verticalLayoutWidget)
        self.exerciseRadioFrets.setObjectName("exerciseRadioFrets")
        self.ExerciseLayout.addWidget(self.exerciseRadioFrets)
        self.exerciseRadioChords = QtWidgets.QRadioButton(self.verticalLayoutWidget)
        self.exerciseRadioChords.setObjectName("exerciseRadioChords")
        self.ExerciseLayout.addWidget(self.exerciseRadioChords)
        self.exerciseRadioNash = QtWidgets.QRadioButton(self.verticalLayoutWidget)
        self.exerciseRadioNash.setObjectName("exerciseRadioNash")
        self.ExerciseLayout.addWidget(self.exerciseRadioNash)
        self.exerciseRadioFreePlay = QtWidgets.QRadioButton(self.verticalLayoutWidget)
        self.exerciseRadioFreePlay.setObjectName("exerciseRadioFreePlay")
        self.ExerciseLayout.addWidget(self.exerciseRadioFreePlay)
        self.verticalLayoutWidget_3 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_3.setGeometry(QtCore.QRect(761, 230, 191, 141))
        self.verticalLayoutWidget_3.setObjectName("verticalLayoutWidget_3")
        self.TunerLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_3)
        self.TunerLayout.setContentsMargins(0, 0, 0, 0)
        self.TunerLayout.setObjectName("TunerLayout")
        self.TunerNote = QtWidgets.QLabel(self.verticalLayoutWidget_3)
        self.TunerNote.setAlignment(QtCore.Qt.AlignBottom|QtCore.Qt.AlignHCenter)
        self.TunerNote.setObjectName("TunerNote")
        self.TunerLayout.addWidget(self.TunerNote)
        self.TunerOffBy = QtWidgets.QLabel(self.verticalLayoutWidget_3)
        self.TunerOffBy.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop)
        self.TunerOffBy.setObjectName("TunerOffBy")
        self.TunerLayout.addWidget(self.TunerOffBy)
        self.tunerScrollBar = QtWidgets.QScrollBar(self.verticalLayoutWidget_3)
        self.tunerScrollBar.setMaximum(100)
        self.tunerScrollBar.setProperty("value", 50)
        self.tunerScrollBar.setOrientation(QtCore.Qt.Horizontal)
        self.tunerScrollBar.setObjectName("tunerScrollBar")
        self.TunerLayout.addWidget(self.tunerScrollBar)
        self.verticalLayoutWidget_4 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_4.setGeometry(QtCore.QRect(761, 20, 191, 191))
        self.verticalLayoutWidget_4.setObjectName("verticalLayoutWidget_4")
        self.MetronomeLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_4)
        self.MetronomeLayout.setContentsMargins(0, 0, 0, 0)
        self.MetronomeLayout.setObjectName("MetronomeLayout")
        self.metroBpmLabel = QtWidgets.QLabel(self.verticalLayoutWidget_4)
        self.metroBpmLabel.setObjectName("metroBpmLabel")
        self.MetronomeLayout.addWidget(self.metroBpmLabel)
        self.metroBpmDial = QtWidgets.QDial(self.verticalLayoutWidget_4)
        self.metroBpmDial.setEnabled(True)
        self.metroBpmDial.setMinimum(30)
        self.metroBpmDial.setMaximum(300)
        self.metroBpmDial.setProperty("value", 120)
        self.metroBpmDial.setNotchesVisible(True)
        self.metroBpmDial.setObjectName("metroBpmDial")
        self.MetronomeLayout.addWidget(self.metroBpmDial)
        self.metroLabel = QtWidgets.QLabel(self.verticalLayoutWidget_4)
        self.metroLabel.setObjectName("metroLabel")
        self.MetronomeLayout.addWidget(self.metroLabel)
        self.metroButton = QtWidgets.QPushButton(self.verticalLayoutWidget_4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.metroButton.sizePolicy().hasHeightForWidth())
        self.metroButton.setSizePolicy(sizePolicy)
        self.metroButton.setObjectName("metroButton")
        self.MetronomeLayout.addWidget(self.metroButton)
        self.verticalLayoutWidget_5 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_5.setGeometry(QtCore.QRect(30, 209, 121, 161))
        self.verticalLayoutWidget_5.setObjectName("verticalLayoutWidget_5")
        self.ReportLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_5)
        self.ReportLayout.setContentsMargins(0, 0, 0, 0)
        self.ReportLayout.setObjectName("ReportLayout")
        self.verticalLayoutWidget_6 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_6.setGeometry(QtCore.QRect(150, 19, 111, 351))
        self.verticalLayoutWidget_6.setObjectName("verticalLayoutWidget_6")
        self.OptionsLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_6)
        self.OptionsLayout.setContentsMargins(0, 0, 0, 0)
        self.OptionsLayout.setObjectName("OptionsLayout")
        self.levelRadio1 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio1.setObjectName("levelRadio1")
        self.OptionsLayout.addWidget(self.levelRadio1)
        self.levelRadio2 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio2.setObjectName("levelRadio2")
        self.OptionsLayout.addWidget(self.levelRadio2)
        self.levelRadio3 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio3.setObjectName("levelRadio3")
        self.OptionsLayout.addWidget(self.levelRadio3)
        self.levelRadio4 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio4.setObjectName("levelRadio4")
        self.OptionsLayout.addWidget(self.levelRadio4)
        self.verticalLayoutWidget_7 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_7.setGeometry(QtCore.QRect(290, 19, 471, 351))
        self.verticalLayoutWidget_7.setObjectName("verticalLayoutWidget_7")
        self.ObjectiveLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_7)
        self.ObjectiveLayout.setContentsMargins(0, 0, 0, 0)
        self.ObjectiveLayout.setObjectName("ObjectiveLayout")
        self.instructionsLabel = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        self.instructionsLabel.setWordWrap(True)
        self.instructionsLabel.setObjectName("instructionsLabel")
        self.ObjectiveLayout.addWidget(self.instructionsLabel)
        self.currentGoalLabel = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        self.currentGoalLabel.setAlignment(QtCore.Qt.AlignBottom|QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft)
        self.currentGoalLabel.setWordWrap(True)
        self.currentGoalLabel.setObjectName("currentGoalLabel")
        self.ObjectiveLayout.addWidget(self.currentGoalLabel)
        self.secondaryGoalLabel = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        self.secondaryGoalLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.secondaryGoalLabel.setObjectName("secondaryGoalLabel")
        self.ObjectiveLayout.addWidget(self.secondaryGoalLabel)
        self.currentStatusLabel = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        self.currentStatusLabel.setText("")
        self.currentStatusLabel.setObjectName("currentStatusLabel")
        self.ObjectiveLayout.addWidget(self.currentStatusLabel)
        self.verticalLayoutWidget_8 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_8.setGeometry(QtCore.QRect(260, 19, 31, 351))
        self.verticalLayoutWidget_8.setObjectName("verticalLayoutWidget_8")
        self.VolumeLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_8)
        self.VolumeLayout.setContentsMargins(0, 0, 0, 0)
        self.VolumeLayout.setObjectName("VolumeLayout")
        self.volumeSlider = QtWidgets.QSlider(self.verticalLayoutWidget_8)
        self.volumeSlider.setProperty("value", 10)
        self.volumeSlider.setSliderPosition(10)
        self.volumeSlider.setOrientation(QtCore.Qt.Vertical)
        self.volumeSlider.setObjectName("volumeSlider")
        self.VolumeLayout.addWidget(self.volumeSlider)
        self.horizontalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(0, 20, 31, 351))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.horizontalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget_2.setGeometry(QtCore.QRect(950, 20, 31, 351))
        self.horizontalLayoutWidget_2.setObjectName("horizontalLayoutWidget_2")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget_2)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_2.setGeometry(QtCore.QRect(30, 0, 121, 21))
        self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(self.verticalLayoutWidget_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.verticalLayoutWidget_9 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_9.setGeometry(QtCore.QRect(150, 0, 71, 21))
        self.verticalLayoutWidget_9.setObjectName("verticalLayoutWidget_9")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_9)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.optionsLabel = QtWidgets.QLabel(self.verticalLayoutWidget_9)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.optionsLabel.sizePolicy().hasHeightForWidth())
        self.optionsLabel.setSizePolicy(sizePolicy)
        self.optionsLabel.setMaximumSize(QtCore.QSize(16777215, 19))
        self.optionsLabel.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop)
        self.optionsLabel.setObjectName("optionsLabel")
        self.verticalLayout_2.addWidget(self.optionsLabel)
        self.verticalLayoutWidget_10 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_10.setGeometry(QtCore.QRect(220, 0, 101, 21))
        self.verticalLayoutWidget_10.setObjectName("verticalLayoutWidget_10")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_10)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.label_3 = QtWidgets.QLabel(self.verticalLayoutWidget_10)
        self.label_3.setAlignment(QtCore.Qt.AlignCenter)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_3.addWidget(self.label_3)
        self.verticalLayoutWidget_11 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_11.setGeometry(QtCore.QRect(760, 0, 191, 21))
        self.verticalLayoutWidget_11.setObjectName("verticalLayoutWidget_11")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_11)
        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.label_4 = QtWidgets.QLabel(self.verticalLayoutWidget_11)
        self.label_4.setAlignment(QtCore.Qt.AlignCenter)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_4.addWidget(self.label_4)
        self.verticalLayoutWidget_12 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_12.setGeometry(QtCore.QRect(430, 0, 161, 21))
        self.verticalLayoutWidget_12.setObjectName("verticalLayoutWidget_12")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_12)
        self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.label_2 = QtWidgets.QLabel(self.verticalLayoutWidget_12)
        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_5.addWidget(self.label_2)
        self.verticalLayoutWidget_13 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_13.setGeometry(QtCore.QRect(760, 210, 191, 21))
        self.verticalLayoutWidget_13.setObjectName("verticalLayoutWidget_13")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_13)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.TunerLabel = QtWidgets.QLabel(self.verticalLayoutWidget_13)
        self.TunerLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.TunerLabel.setObjectName("TunerLabel")
        self.verticalLayout_6.addWidget(self.TunerLabel)
        BassBot.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(BassBot)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 987, 22))
        self.menubar.setObjectName("menubar")
        BassBot.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(BassBot)
        self.statusbar.setObjectName("statusbar")
        BassBot.setStatusBar(self.statusbar)

        self.retranslateUi(BassBot)
        QtCore.QMetaObject.connectSlotsByName(BassBot)
################################################################################
#END PYUIC5 SECTION
################################################################################
        # Set up the worker thread for note handling
        self.thread = QThread()
        self.worker = Worker()
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.finished.connect(self.thread.deleteLater)
        self.worker.progress.connect(self.reportNote)
        self.worker.tuning.connect(self.reportTuning)
        self.thread.start()
        print(ROBOT)

        # Set up sounds
        time.sleep(1)
        mixer.init()
        self.clickSound = mixer.Sound(CLICK_SOUND)
        self.hiClickSound = mixer.Sound(HI_CLICK_SOUND)
        self.loClickSound = mixer.Sound(LO_CLICK_SOUND)
        self.rightSound = mixer.Sound(RIGHT_SOUND)
        self.wrongSound = mixer.Sound(WRONG_SOUND)

        # Set up the metronome
        self.beatCount = 0
        self.metroButton.clicked.connect(self.metroClicked)
        self.metroTimer = QTimer(timerType=Qt.PreciseTimer)
        self.metroTimer.timeout.connect(self.metroTimeout)
        self.metroIsPlaying = False
        self.metroBpmDial.valueChanged.connect(self.metroDialChanged)

        # If we're in chord mode, then the metronome will also key off the
        # chord transitions
        self.chordTimer = QTimer(timerType=Qt.PreciseTimer)
        self.chordTimer.timeout.connect(self.chordTimeout)

        # Handle the volume bar
        self.volumeSlider.valueChanged.connect(self.volumeChanged)
        self.volumeSlider.sliderReleased.connect(self.volumeReleased)
        vol = self.volumeSlider.value() / 100.0
        self.clickSound.set_volume(vol)
        self.hiClickSound.set_volume(vol)
        self.loClickSound.set_volume(vol)
        self.rightSound.set_volume(vol)
        self.wrongSound.set_volume(vol)

        # Set up the level configuration
        self.currentExercise = 0
        self.exerciseRadioTuner.clicked.connect(self.exerciseClicked)
        self.exerciseRadioFrets.clicked.connect(self.exerciseClicked)
        self.exerciseRadioChords.clicked.connect(self.exerciseClicked)
        self.exerciseRadioNash.clicked.connect(self.exerciseClicked)
        self.exerciseRadioFreePlay.clicked.connect(self.exerciseClicked)
        self.exerciseRadioTuner.setChecked(True)
        self.levelRadio1.clicked.connect(lambda: self.levelClicked(1))
        self.levelRadio2.clicked.connect(lambda: self.levelClicked(2))
        self.levelRadio3.clicked.connect(lambda: self.levelClicked(3))
        self.levelRadio4.clicked.connect(lambda: self.levelClicked(4))
        self.levelRadio1.setChecked(True)
        self.exerciseClicked()

    def retranslateUi(self, BassBot):
        _translate = QtCore.QCoreApplication.translate
        BassBot.setWindowTitle(_translate("BassBot", "BassBot"))
        self.exerciseRadioTuner.setText(_translate("BassBot", "Tuner"))
        self.exerciseRadioFrets.setText(_translate("BassBot", "Fret Finder"))
        self.exerciseRadioChords.setText(_translate("BassBot", "Chord Shapes"))
        self.exerciseRadioNash.setText(_translate("BassBot", "Nashville Notation"))
        self.exerciseRadioFreePlay.setText(_translate("BassBot", "Free Play"))
        self.TunerNote.setText(_translate("BassBot", "Note: "))
        self.TunerOffBy.setText(_translate("BassBot", "Tuning"))
        self.metroBpmLabel.setText(_translate("BassBot", "BPM: " + str(self.metroBpmDial.value())))
        self.metroLabel.setText(_translate("BassBot", "Metronome Stopped"))
        self.metroButton.setText(_translate("BassBot", "Start/Stop"))
        self.levelRadio1.setText(_translate("BassBot", "Level 1"))
        self.levelRadio2.setText(_translate("BassBot", "Level 2"))
        self.levelRadio3.setText(_translate("BassBot", "Level 3"))
        self.levelRadio4.setText(_translate("BassBot", "Level 4"))
        self.instructionsLabel.setText(_translate("BassBot", "Instructions for level here"))
        self.currentGoalLabel.setText(_translate("BassBot", "Current note/shape/whateves here"))
        self.secondaryGoalLabel.setText(_translate("BassBot", "Arpeggio order/current chord here"))
        self.label.setText(_translate("BassBot", "Exercise"))
        self.optionsLabel.setText(_translate("BassBot", "Level"))
        self.label_3.setText(_translate("BassBot", "Volume"))
        self.label_4.setText(_translate("BassBot", "Metronome"))
        self.label_2.setText(_translate("BassBot", "Objective"))
        self.TunerLabel.setText(_translate("BassBot", "Tuner"))

    def levelClicked(self, level):
        #The tuner has no levels, do nothing
        if self.exerciseRadioTuner.isChecked():
            self.currentExercise = 0
            return

        if self.exerciseRadioFrets.isChecked():
            self.currentExercise = fretFinder(level)

        elif self.exerciseRadioChords.isChecked():
            self.currentExercise = chordFinder(level)
        elif self.exerciseRadioNash.isChecked():
            self.currentExercise = nashville(level)
        else: #if self.exerciseRadioFreePlay.isChecked():
            self.currentExercise = freePlay(level)
        self.instructionsLabel.setText(self.currentExercise.getInstructions())
        self.currentGoalLabel.setText(self.currentExercise.getGoal())
        self.secondaryGoalLabel.setText(self.currentExercise.getSecondaryGoal())
        self.currentStatusLabel.setText(self.currentExercise.getStatus())
        self.currentExercise.set_volume(self.volumeSlider.value() / 100.0)

    def exerciseClicked(self):
        if self.levelRadio1.isChecked():
            level = 1
        elif self.levelRadio2.isChecked():
            level = 2
        elif self.levelRadio3.isChecked():
            level = 3
        elif self.levelRadio4.isChecked():
            level = 4
        else:
            level = 1
        if self.exerciseRadioTuner.isChecked():
            self.currentExercise = 0
            self.instructionsLabel.setText("Play a note, use the tuner")
            self.currentGoalLabel.setText("")
            self.secondaryGoalLabel.setText("")
            self.currentStatusLabel.setText("")
        else:
            if self.exerciseRadioFrets.isChecked():
                self.currentExercise = fretFinder(level)
                self.chordTimer.stop()
            elif self.exerciseRadioChords.isChecked():
                self.currentExercise = chordFinder(level)
                self.chordTimer.stop()
                self.metroTimer.stop()
                self.metroIsPlaying = False
                self.metroLabel.setText("metronome off")
            elif self.exerciseRadioNash.isChecked():
                self.currentExercise = nashville(level)
            else: #if self.exerciseRadioFreePlay.isChecked():
                self.currentExercise = freePlay(level)

            self.currentExercise.set_volume(self.volumeSlider.value() / 100.0)
            self.instructionsLabel.setText(self.currentExercise.getInstructions())
            self.currentGoalLabel.setText(self.currentExercise.getGoal())
            self.secondaryGoalLabel.setText(self.currentExercise.getSecondaryGoal())
            self.currentStatusLabel.setText("")

    def volumeReleased(self):
        self.volumeChanged()
        self.rightSound.play()

    def setAllVolumes(self, vol):
        self.hiClickSound.set_volume(vol)
        self.loClickSound.set_volume(vol)
        self.clickSound.set_volume(vol)
        self.rightSound.set_volume(vol)
        self.wrongSound.set_volume(vol)
        if self.currentExercise != 0:
            self.currentExercise.set_volume(vol)


    def volumeChanged(self):
        vol = self.volumeSlider.value() / 100.0
        self.setAllVolumes(vol)

    def metroDialChanged(self):
        self.metroBpmLabel.setText("BPM: " + str(self.metroBpmDial.value()))

    def metroClicked(self):
        self.metroLabel.setText("button pressed!")
        msDelay = int(60000.0/self.metroBpmDial.value())

        if self.metroIsPlaying == True:
            self.metroIsPlaying = False
            self.metroTimer.stop()
            self.chordTimer.stop()
            if self.exerciseRadioFreePlay.isChecked():
                self.currentExercise.setNewGoal()
                self.secondaryGoalLabel.setText(self.currentExercise.getSecondaryGoal())
            self.metroLabel.setText("metronome off")
        else:
            self.metroIsPlaying = True
            self.beatCount = 1
            self.metroTimer.start(msDelay)
            if self.exerciseRadioFreePlay.isChecked():
                # Eventually, this will be based on time signature and num bars
                # The first time, subtract one to count the init click
                self.chordTimer.start((msDelay * 4) - 1)
            self.hiClickSound.play()
            self.metroLabel.setText("metronome on")

    def metroTimeout(self):
        msDelay = int(60000.0/self.metroBpmDial.value())
        self.beatCount += 1
        if self.beatCount == 5:
            self.beatCount = 1
            self.hiClickSound.play()
        else:
            self.loClickSound.play()
        self.metroTimer.start(msDelay)

    def chordTimeout(self):
        msDelay = int(60000.0/self.metroBpmDial.value())
        self.chordTimer.start((msDelay * 4 * 2) - 1)
        if self.exerciseRadioFreePlay.isChecked():
            self.currentExercise.advanceChord()
            self.secondaryGoalLabel.setText(self.currentExercise.getSecondaryGoal())

    def reportTuning(self, offby):
        tuneString = '%+.1f'%(offby*100)
        self.TunerOffBy.setText(tuneString + " cents")

        # Tuning comes in -0.5 to +0.5.  So x 100 to get from -50:50, then
        # +50 to get from 0:100
        tuneVal = (offby * 100) + 50
        if tuneVal < 0:
            tuneVal = 0
        elif tuneVal > 100:
            tuneVal = 100
        self.tunerScrollBar.setProperty("value", int(tuneVal))
        self.tunerScrollBar.setSliderPosition(int(tuneVal))


    def reportNote(self, note):
        self.TunerNote.setText("Note: " + str(note))

        if note == 'none':
            self.TunerOffBy.setText("")
            self.tunerScrollBar.setProperty("value", 50)
            self.tunerScrollBar.setSliderPosition(50)

        if self.currentExercise != 0:
            if self.currentExercise.evaluateNote(note):
                self.instructionsLabel.setText(self.currentExercise.getInstructions())
                self.currentGoalLabel.setText(self.currentExercise.getGoal())
                self.secondaryGoalLabel.setText(self.currentExercise.getSecondaryGoal())
            self.currentStatusLabel.setText(self.currentExercise.getStatus())

if __name__ == "__main__":
    import sys

    #pygame.init()
    #mixer.init()

    app = QtWidgets.QApplication(sys.argv)

    app.setStyle('Fusion') #Style needed for palette to work
    # Dark Palette (found on github, couldn't track the original author)
    default_palette = QPalette()
    dark_palette = QPalette()
    dark_palette.setColor(QPalette.Window, QColor(53, 53, 53))
    dark_palette.setColor(QPalette.WindowText, Qt.white)
    dark_palette.setColor(QPalette.Base, QColor(25, 25, 25))
    dark_palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    dark_palette.setColor(QPalette.ToolTipBase, Qt.white)
    dark_palette.setColor(QPalette.ToolTipText, Qt.white)
    dark_palette.setColor(QPalette.Text, Qt.white)
    dark_palette.setColor(QPalette.Button, QColor(53, 53, 53))
    dark_palette.setColor(QPalette.ButtonText, Qt.white)
    dark_palette.setColor(QPalette.BrightText, Qt.red)
    dark_palette.setColor(QPalette.Link, QColor(42, 130, 218))
    dark_palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    dark_palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(dark_palette)

    BassBot = QtWidgets.QMainWindow()
    ui = Ui_BassBot()
    ui.setupUi(BassBot)
    BassBot.show()
    sys.exit(app.exec_())
