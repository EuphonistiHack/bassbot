#! /usr/bin/python3

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test1.ui'
#
# Created by: PyQt5 UI code generator 5.15.3
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QTimer, Qt, QObject, QThread, pyqtSignal

from pygame import mixer

import aubio
import numpy as num
import pyaudio
import sys
from threading import Thread, Event
import argparse
import random
import datetime

NOTE_NAMES = 'C C# D D# E F F# G G# A A# B'.split()

# Track all the notes on a per-fret basis. <n>_NOTES will give you the note by
# fret.  0 is open, 1 is first fret, etc.
# ok, so there are more than 18 frets, but who's actually meedly meedlying up
# in the stratosphere with the 24th fret?
NUM_FRETS = 18
G_NOTES = 'G2 G#2 A2 A#2 B2 C3 C#3 D3 D#3 E3 F3 F#3 G3 G#3 A3 A#3 B3 C4 C#4'.split()
D_NOTES = 'D2 D#2 E2 F2 F#2 G2 G#2 A2 A#2 B2 C3 C#3 D3 D#3 E3 F3 F#3 G3 G#3'.split()
A_NOTES = 'A1 A#1 B1 C2 C#2 D2 D#2 E2 F2 F#2 G2 G#2 A2 A#2 B2 C3 C#3 D3 D#3'.split()
E_NOTES = 'E1 F1 F#1 G1 G#1 A1 A#1 B1 C2 C#2 D2 D#2 E2 F2 F#2 G2 G#2 A2 A#2'.split()
B_NOTES = 'B0 C1 C#1 D1 D#1 E1 F1 F#1 G1 G#1 A1 A#1 B1 C2 C#2 D2 D#2 E2 E#2'.split()
# String is mostly used to convert string number to name
STRING_LIST = 'E A D G'.split()
# String fret list is used to generate a random note on a random fret.
# so [0][3] will give you the E string, fret 3, or an G1
STRING_FRET_LIST = [E_NOTES, A_NOTES, D_NOTES, G_NOTES]
SHAPE_NAMES = ['major 7', 'dom 7', 'minor 7', 'm7 flat 5']

# The chord shape will give an offset from the root chord in [string][fret]
# format.  For example, a C major 7 will contain the root note (C), then a note
# one string up and one fret down (E) [1][-1], then a note one string up and
# two strings down from the root (G): [1][2], then a note two strings up and
# one string down (B): [2][1], and ending on a note two strings up and two
# strings down (C): [2][2]

MAJOR7_SHAPE = [[1,-1], [1,2], [2,1], [2,2]]
DOM7_SHAPE = [[1,-1], [1,2], [2,0], [2,2]]
MINOR7_SHAPE = [[1,-2], [1,2], [2,0], [2,2]]
MINOR7FLAT5_SHAPE = [[1,-2], [1,1], [2,0], [2,2]]
SHAPE_LIST = [MAJOR7_SHAPE, DOM7_SHAPE, MINOR7_SHAPE, MINOR7FLAT5_SHAPE]

WRONG_SOUND = 'custWrong.ogg'
RIGHT_SOUND = 'custRight.ogg'

ROBOT = """
~~~~~~~~~~BASSBOT~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++-----------------------------|---------------------(x)-------+--------------++
||  ,-.         \\.===./        |                     |         |     ( )      ||
||--o  |:---|---| n n |--------|------------#(x)-----|---------|--------------||
||    /     |)   \\_`_/         |    (x)      |       |         |              ||
||---/---------.=(+++)=.-----(x)----|--------|-----------------|--------------||
||  /    |  o="  (___)  "=o         |        |                 |              ||
||-------|)------|_|_|--------------|--------------------------|--------------||
||               /_|_\\                                         |              ||
++-------------------------------------------------------------+--------------++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"""

# some functions I found from a ukelele tuner app, all of which are based on
# https://newt.phys.unsw.edu.au/jw/notes.html
# These are used to convert frequencies to midi numbers and note names
def freq_to_number(f): return 69 + 12*num.log2(f/440.0)
def number_to_freq(n): return 440 * 2.0**((n-69)/12.0)
def note_name(n): return NOTE_NAMES[n % 12] + str(int(n/12 - 1))

# Some constants for setting the PyAudio capture and aubio note detection
# parameters
BUFFER_SIZE             = 4096*2
CHANNELS                = 1
FORMAT                  = pyaudio.paFloat32
METHOD                  = "default"
SAMPLE_RATE             = 44100
HOP_SIZE                = BUFFER_SIZE//2
PERIOD_SIZE_IN_FRAME    = HOP_SIZE

LEVEL_TYPE_FRETFINDER   = 0
LEVEL_TYPE_CHORDSHAPES  = 1

gVolume = 1.0

class sessionInfo:
    """Track performance statics through playing"""
    numRight = 0
    numWrong = 0
    timeList = ''
    level = 0

    def __init__(self, level):
        self.numRight = 0
        self.numWrong = 0
        self.timeList = ''
        self.level = level

class AudioHandler:
    """Set up mic input, take samples when tick is called, provide freq and vol"""

    def __init__(self):
         # Initiating PyAudio object.
        pA = pyaudio.PyAudio()
        # Open the microphone stream.
        self.mic = pA.open(format=FORMAT, channels=CHANNELS,
                rate=SAMPLE_RATE, input=True,
                frames_per_buffer=PERIOD_SIZE_IN_FRAME)

        # Initiating Aubio's pitch detection object.
        self.pDetection = aubio.pitch(METHOD, BUFFER_SIZE,
            HOP_SIZE, SAMPLE_RATE)
        # Set unit.
        self.pDetection.set_unit("Hz")
        # Frequency under -40 dB will considered
        # as a silence.
        self.pDetection.set_silence(-30)

    def processAudio(self):
        # Always listening to the microphone.
        data = self.mic.read(PERIOD_SIZE_IN_FRAME)
        # Convert into number that Aubio understand.
        samples = num.fromstring(data,
            dtype=aubio.float_type)
        # Finally get the pitch.
        pitch = self.pDetection(samples)[0]
        # Compute the energy (volume)
        # of the current frame.
        volume = num.sum(samples**2)/len(samples)
        return pitch, volume

class levelConfig():
    evaluateFxn = 0

class chordFinder():
    """Handle instructions, goals, and evaluations for chordFinder exercises"""
    def getInstructions(self):
        if self.level == 1:
            return "Level 1: Play a random chord shape arpeggio for a middle C"
        elif self.level == 2:
            return "Level 2: Play a random chord shape for a random root"
        elif self.level == 3:
            return "Level 3: Play a major 7 arpeggio for a middle C in a random order"
        elif self.level == 4:
            return "Level 4: Play a random chord shape for a middle C in a random order"
        elif self.level == 5:
            return "Level 5: Play a random chord shape for a random root in a random order"
        else:
            print("DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!")
            return "DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!"

    def __init__(self, level = 1, lastNote = ''):
        self.level = level
        self.toPlay = lastNote
        self.ignoreNote = lastNote
        self.numRight = 0
        self.numWrong = 0

        self.chordTones = []
        for i in range(5):
            self.chordTones.append('')
        self.order = []
        self.noteIdx = 0

        self.setNewGoal()

    def getGoal(self):
        return self.goal

    def getArpFromIdx(self, arpNum):
        if arpNum == 0:
            return 1
        elif arpNum == 1:
            return 3
        elif arpNum == 2:
            return 5
        elif arpNum == 3:
            return 7
        elif arpNum == 4:
            return 8
        else:
            return 0

    def setNewGoal(self):
        string = 0
        fret = 0
        if self.level == 1:
            string = 0
            fret = 8
            self.order = [0, 1, 2, 3, 4, 3, 2, 1, 0]
        elif self.level == 2:
            # Must be string 0:1
            # Must be fret 2:12, though 12th fret limit is a bit artificial
            string = random.randrange(2)
            fret = 2 + random.randrange(11)
            self.order = [0, 1, 2, 3, 4, 3, 2, 1, 0]
        elif self.level == 3:
            string = 0
            fret = 8
            self.order = [0, 1, 2, 3, 4]
            random.shuffle(self.order)
        elif self.level == 4:
            string = 0
            fret = 8
            self.order = [0, 1, 2, 3, 4]
            random.shuffle(self.order)
        elif self.level == 5:
            string = random.randrange(2)
            fret = 2 + random.randrange(11)
            order = [0, 1, 2, 3, 4]
            random.shuffle(self.order)

        orderString = ''
        for i in self.order:
            orderString += str(self.getArpFromIdx(i)) + " "

        # hi/lo/mid convention:
        # low is anything from C1 to B1.  Mid is anything from C2 to B2.  High is
        # anything from C3 to B3.  C4 and C#4 are the devil and don't exist.
        # I'm not super happy with this, but... I can't think of a better way to do
        # it, especially when we expand to support 5 string basses later
        # While we're at it, lets strip the number off the chord name as well.
        chordRoot = STRING_FRET_LIST[string][fret]
        if chordRoot[-1] == '1':
            prefix = 'low '
            chordRoot = chordRoot[:-1]
        elif chordRoot[-1] == '2':
            prefix = 'mid '
            chordRoot = chordRoot[:-1]
        else:
            prefix = 'high '
            chordRoot = chordRoot[:-1]

        # shape selection
        if self.level == 1:
            shape_num = 0
        else:
            shape_num = random.randrange(4)
        shape = SHAPE_LIST[shape_num]

        self.chordTones[0] = STRING_FRET_LIST[string][fret]
        for i in range(1,5):
            self.chordTones[i] = STRING_FRET_LIST[string+shape[i-1][0]][fret+shape[i-1][1]]

        print(SHAPE_NAMES[shape_num] + " " + prefix + chordRoot)
        self.goal = SHAPE_NAMES[shape_num] + " " + prefix + chordRoot
        if (self.level >= 3):
            print("order: " + orderString)
            self.goal += "\norder: " + orderString
            self.goal += "\nplayed: "
        self.noteIdx = 0;

    def evaluateNote(self, playedNote):
        # if this is a note we're ignoring, do nothing
        if (playedNote == self.ignoreNote):
            return False

        # if this is a mute note, clear the ignore list and do nothing
        if playedNote == 'none':
            self.ignoreNote = playedNote
            return False

        self.toPlay = self.chordTones[self.order[self.noteIdx]]
        self.ignoreNote = playedNote

        if playedNote == self.toPlay:
            self.numRight += 1
            print("correct on " + str(self.getArpFromIdx(self.order[self.noteIdx])))

            if self.noteIdx >= len(self.order) -1:
                self.setNewGoal()
                print("Exercise complete!  Next note!")
                return True
            else:
                self.goal += str(self.getArpFromIdx(self.order[self.noteIdx])) + " "
                self.noteIdx += 1
                return True
        else:
            print("wrongzo!")
            print("   expected " + str(self.toPlay))
            print("   heard " + str(playedNote))

            self.numWrong += 1
            self.goal = "WRONG!!!! " + self.goal
            return True

class fretFinder():
    """Handle instructions, goals, and evaluations for fretFinder exercises"""
    def getInstructions(self):
        if self.level == 1:
            return "Level 1: Play the string listed!"
        elif self.level == 2:
            retVal = "Level 2: Play the note listed!\n"
            return retVal + "  The answer will always be on one of the first 4 frets"
        elif self.level == 3:
            retVal = "Level 3: Play the note listed!"
            return retVal + "  ... but we're sticking below 12 frets"
        elif self.level == 4:
            retVal = "Level 4: Play the note listed!"
            return retVal + "  ... but we're sticking below " + str(NUM_FRETS) + " frets"
        else:
            print("DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!")
            return "DEV MADE AN OOPS IN FRETFINDER, GETINSTRUCTIONS!!!!"

    def setNewGoal(self):
        while self.toPlay == self.ignoreNote:
            # Select a random string, 1-4
            string = random.randrange(4)

            # Select the fret for that string
            if (self.level == 1):
                fret = 0
                prefix = ''
            elif (self.level == 2):
                fret = random.randrange(5)
                prefix = ''
            elif (self.level == 3):
                fret = random.randrange(13)
                # Any mode with fret 12 or higher in play needs a high/low prefix to
                # differentiate between open string and the 12th+ fret
                if fret >= 12:
                    prefix = 'high '
                else:
                    prefix = 'low '
            elif (self.level == 4):
                fret = random.randrange(NUM_FRETS)
                if fret >= 12:
                    prefix = 'high '
                else:
                    prefix = 'low '
            else:
                print("dev made an oops- unknown level: " + str(self.level))
                return 0

            self.toPlay = STRING_FRET_LIST[string][fret]

        self.goal = STRING_LIST[string] + " string: " + prefix + self.toPlay

    def __init__(self, level = 1, lastNote = ''):
        self.level = level
        self.toPlay = lastNote
        self.ignoreNote = lastNote
        self.numRight = 0
        self.numWrong = 0

        self.setNewGoal()

    def getGoal(self):
        return self.goal

    def evaluateNote(self, playedNote):
        # if this is a note we're ignoring, do nothing
        if (playedNote == self.ignoreNote):
            return False

        # if this is a mute note, clear the ignore list and do nothing
        if playedNote == 'none':
            self.ignoreNote = playedNote
            return False

        if playedNote == self.toPlay:
            self.numRight += 1
            print("correct!  played " + str(playedNote))
            self.ignoreNote = playedNote
            self.setNewGoal()
            return True
        else:
            print("wrongzo!")
            print("   expected " + str(self.toPlay))
            print("   heard " + str(playedNote))
            self.ignoreNote = playedNote
            self.numWrong += 1
            self.goal = "WRONG!!!! " + self.goal
            return True

class Worker (QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(str)
    confidenceLevel = 3

    def run(self):
        self.aHandler = AudioHandler()
        self.resultList = []
        while True:
            self.sampleNote()
        self.finished.emit()

    def sampleNote(self):
        result = self.aHandler.processAudio()
        pitch = result[0]
        volume = result[1]
        # Get note number and nearest note
        if (pitch == 0.0):
            name = "none"
        else:
            n = freq_to_number(pitch)
            n0 = int(round(n))
            name = note_name(n0)

        # Format the volume output so it only
        # displays at most six numbers behind 0.
        volume = "{:6f}".format(volume)
        # Finally print the pitch and the volume.
        # print(name + " " + str(pitch) + " " + str(volume))
        # if we have confidenceLevel matches in a row, return this result
        self.resultList.insert(0, name)
        if len(self.resultList) >= self.confidenceLevel:
            # Count the number of entires in the list.  If same as length, then
            # the list all matches and we have hit enough confidence to return
            # a note value. Otherwise, pop the last entry and continue
            if (self.resultList.count(name) == len(self.resultList)):
                self.progress.emit(name)
                self.resultList = []
            else:
                self.resultList.pop()

################################################################################
# THIS IS AUTOGENERATED BY PYUIC5!!!
# DO NOT MAKE ANY CHANGES TO THIS BLOCK!!
# If you want to tie signals to these widgets, change their init params, add
# or remove, etc etc etc use Qt Designer and make them to the .ui file.
# Tieing signals, starting timers, etc should be done below the
# END PYUIC5 SECTION section.
################################################################################
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(995, 487)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(31, 0, 121, 211))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.ExerciseLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.ExerciseLayout.setContentsMargins(0, 0, 0, 0)
        self.ExerciseLayout.setObjectName("ExerciseLayout")
        self.label = QtWidgets.QLabel(self.verticalLayoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop)
        self.label.setObjectName("label")
        self.ExerciseLayout.addWidget(self.label)
        self.exerciseRadioFrets = QtWidgets.QRadioButton(self.verticalLayoutWidget)
        self.exerciseRadioFrets.setObjectName("exerciseRadioFrets")
        self.ExerciseLayout.addWidget(self.exerciseRadioFrets)
        self.exerciseRadioChords = QtWidgets.QRadioButton(self.verticalLayoutWidget)
        self.exerciseRadioChords.setObjectName("exerciseRadioChords")
        self.ExerciseLayout.addWidget(self.exerciseRadioChords)
        self.verticalLayoutWidget_3 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_3.setGeometry(QtCore.QRect(761, 190, 191, 161))
        self.verticalLayoutWidget_3.setObjectName("verticalLayoutWidget_3")
        self.TunerLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_3)
        self.TunerLayout.setContentsMargins(0, 0, 0, 0)
        self.TunerLayout.setObjectName("TunerLayout")
        self.TunerNote = QtWidgets.QLabel(self.verticalLayoutWidget_3)
        self.TunerNote.setAlignment(QtCore.Qt.AlignCenter)
        self.TunerNote.setObjectName("TunerNote")
        self.TunerLayout.addWidget(self.TunerNote)
        self.tunerScrollBar = QtWidgets.QScrollBar(self.verticalLayoutWidget_3)
        self.tunerScrollBar.setMaximum(100)
        self.tunerScrollBar.setProperty("value", 50)
        self.tunerScrollBar.setOrientation(QtCore.Qt.Horizontal)
        self.tunerScrollBar.setObjectName("tunerScrollBar")
        self.TunerLayout.addWidget(self.tunerScrollBar)
        self.verticalLayoutWidget_4 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_4.setGeometry(QtCore.QRect(761, 0, 191, 191))
        self.verticalLayoutWidget_4.setObjectName("verticalLayoutWidget_4")
        self.MetronomeLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_4)
        self.MetronomeLayout.setContentsMargins(0, 0, 0, 0)
        self.MetronomeLayout.setObjectName("MetronomeLayout")
        self.metroBpmLabel = QtWidgets.QLabel(self.verticalLayoutWidget_4)
        self.metroBpmLabel.setObjectName("metroBpmLabel")
        self.MetronomeLayout.addWidget(self.metroBpmLabel)
        self.metroBpmDial = QtWidgets.QDial(self.verticalLayoutWidget_4)
        self.metroBpmDial.setEnabled(True)
        self.metroBpmDial.setMinimum(30)
        self.metroBpmDial.setMaximum(300)
        self.metroBpmDial.setProperty("value", 120)
        self.metroBpmDial.setNotchesVisible(True)
        self.metroBpmDial.setObjectName("metroBpmDial")
        self.MetronomeLayout.addWidget(self.metroBpmDial)
        self.metroLabel = QtWidgets.QLabel(self.verticalLayoutWidget_4)
        self.metroLabel.setObjectName("metroLabel")
        self.MetronomeLayout.addWidget(self.metroLabel)
        self.metroButton = QtWidgets.QPushButton(self.verticalLayoutWidget_4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.metroButton.sizePolicy().hasHeightForWidth())
        self.metroButton.setSizePolicy(sizePolicy)
        self.metroButton.setObjectName("metroButton")
        self.MetronomeLayout.addWidget(self.metroButton)
        self.verticalLayoutWidget_5 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_5.setGeometry(QtCore.QRect(30, 209, 121, 141))
        self.verticalLayoutWidget_5.setObjectName("verticalLayoutWidget_5")
        self.ReportLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_5)
        self.ReportLayout.setContentsMargins(0, 0, 0, 0)
        self.ReportLayout.setObjectName("ReportLayout")
        self.verticalLayoutWidget_6 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_6.setGeometry(QtCore.QRect(150, -1, 111, 351))
        self.verticalLayoutWidget_6.setObjectName("verticalLayoutWidget_6")
        self.OptionsLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_6)
        self.OptionsLayout.setContentsMargins(0, 0, 0, 0)
        self.OptionsLayout.setObjectName("OptionsLayout")
        self.optionsLabel = QtWidgets.QLabel(self.verticalLayoutWidget_6)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.optionsLabel.sizePolicy().hasHeightForWidth())
        self.optionsLabel.setSizePolicy(sizePolicy)
        self.optionsLabel.setMaximumSize(QtCore.QSize(16777215, 19))
        self.optionsLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.optionsLabel.setObjectName("optionsLabel")
        self.OptionsLayout.addWidget(self.optionsLabel)
        self.levelRadio1 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio1.setObjectName("levelRadio1")
        self.OptionsLayout.addWidget(self.levelRadio1)
        self.levelRadio2 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio2.setObjectName("levelRadio2")
        self.OptionsLayout.addWidget(self.levelRadio2)
        self.levelRadio3 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio3.setObjectName("levelRadio3")
        self.OptionsLayout.addWidget(self.levelRadio3)
        self.levelRadio4 = QtWidgets.QRadioButton(self.verticalLayoutWidget_6)
        self.levelRadio4.setObjectName("levelRadio4")
        self.OptionsLayout.addWidget(self.levelRadio4)
        self.verticalLayoutWidget_7 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_7.setGeometry(QtCore.QRect(290, -1, 471, 351))
        self.verticalLayoutWidget_7.setObjectName("verticalLayoutWidget_7")
        self.ObjectiveLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_7)
        self.ObjectiveLayout.setContentsMargins(0, 0, 0, 0)
        self.ObjectiveLayout.setObjectName("ObjectiveLayout")
        self.instructionsLabel = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        self.instructionsLabel.setWordWrap(True)
        self.instructionsLabel.setObjectName("instructionsLabel")
        self.ObjectiveLayout.addWidget(self.instructionsLabel)
        self.currentGoalLabel = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        self.currentGoalLabel.setWordWrap(True)
        self.currentGoalLabel.setObjectName("currentGoalLabel")
        self.ObjectiveLayout.addWidget(self.currentGoalLabel)
        self.verticalLayoutWidget_8 = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget_8.setGeometry(QtCore.QRect(260, -1, 31, 351))
        self.verticalLayoutWidget_8.setObjectName("verticalLayoutWidget_8")
        self.VolumeLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_8)
        self.VolumeLayout.setContentsMargins(0, 0, 0, 0)
        self.VolumeLayout.setObjectName("VolumeLayout")
        self.label_3 = QtWidgets.QLabel(self.verticalLayoutWidget_8)
        self.label_3.setObjectName("label_3")
        self.VolumeLayout.addWidget(self.label_3)
        self.volumeSlider = QtWidgets.QSlider(self.verticalLayoutWidget_8)
        self.volumeSlider.setSliderPosition(75)
        self.volumeSlider.setOrientation(QtCore.Qt.Vertical)
        self.volumeSlider.setObjectName("volumeSlider")
        self.VolumeLayout.addWidget(self.volumeSlider)
        self.horizontalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(0, 0, 31, 351))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.horizontalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget)
        self.horizontalLayoutWidget_2.setGeometry(QtCore.QRect(950, 0, 31, 351))
        self.horizontalLayoutWidget_2.setObjectName("horizontalLayoutWidget_2")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget_2)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 995, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
################################################################################
#END PYUIC5 SECTION
################################################################################
        # Set up the metronome
        self.clickSound = mixer.Sound('click.wav')
        self.metroButton.clicked.connect(self.metroClicked)
        self.metroTimer = QTimer(timerType=Qt.PreciseTimer)
        self.metroTimer.timeout.connect(self.metroTimeout)
        self.metroIsPlaying = False
        self.metroBpmDial.valueChanged.connect(self.metroDialChanged)

        self.volumeSlider.valueChanged.connect(self.volumeChanged)
        self.globalVolume = self.volumeSlider.value() / 100.0

        # Set up the note processing loop
        #self.noteTimer = QTimer()
        #self.noteTimer.timeout.connect(self.sampleNote)
        #self.noteTimer.start(0)
        #self.aHandler = AudioHandler()

        # Set up the worker thread for note handling
        self.thread = QThread()
        self.worker = Worker()
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.finished.connect(self.thread.deleteLater)
        self.worker.progress.connect(self.reportNote)
        self.thread.start()
        print(ROBOT)

        # Set up the level configuration
        self.currentExercise = 0
        self.exerciseRadioFrets.clicked.connect(self.exerciseClicked)
        self.exerciseRadioChords.clicked.connect(self.exerciseClicked)
        self.exerciseRadioFrets.setChecked(True)
        self.levelRadio1.clicked.connect(lambda: self.levelClicked(1))
        self.levelRadio2.clicked.connect(lambda: self.levelClicked(2))
        self.levelRadio3.clicked.connect(lambda: self.levelClicked(3))
        self.levelRadio4.clicked.connect(lambda: self.levelClicked(4))
        self.levelRadio1.setChecked(True)
        self.exerciseClicked()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Level"))
        self.exerciseRadioFrets.setText(_translate("MainWindow", "Fret Finder"))
        self.exerciseRadioChords.setText(_translate("MainWindow", "Chord Shapes"))
        self.TunerNote.setText(_translate("MainWindow", "Note: "))
        self.metroBpmLabel.setText(_translate("MainWindow", "BPM: " + str(self.metroBpmDial.value())))
        self.metroLabel.setText(_translate("MainWindow", "Metronome Stopped"))
        self.metroButton.setText(_translate("MainWindow", "Start/Stop"))
        self.optionsLabel.setText(_translate("MainWindow", "Options"))
        self.levelRadio1.setText(_translate("MainWindow", "Level 1"))
        self.levelRadio2.setText(_translate("MainWindow", "Level 2"))
        self.levelRadio3.setText(_translate("MainWindow", "Level 3"))
        self.levelRadio4.setText(_translate("MainWindow", "Level 4"))
        self.instructionsLabel.setText(_translate("MainWindow", "Instructions for level here"))
        self.currentGoalLabel.setText(_translate("MainWindow", "Current note/shape/whateves here"))
        self.label_3.setText(_translate("MainWindow", "Vol"))

    def levelClicked(self, level):
        if self.exerciseRadioFrets.isChecked():
            self.currentExercise = fretFinder(level)
            self.instructionsLabel.setText(self.currentExercise.getInstructions())
            self.currentGoalLabel.setText(self.currentExercise.getGoal())
        else:
            self.currentExercise = chordFinder(level)
            self.instructionsLabel.setText(self.currentExercise.getInstructions())
            self.currentGoalLabel.setText(self.currentExercise.getGoal())

    def exerciseClicked(self):
        if self.levelRadio1.isChecked():
            level = 1
        elif self.levelRadio2.isChecked():
            level = 2
        elif self.levelRadio3.isChecked():
            level = 3
        elif self.levelRadio4.isChecked():
            level = 4
        else:
            level = 1
        if self.exerciseRadioFrets.isChecked():
            self.currentExercise = fretFinder(level)
            self.instructionsLabel.setText(self.currentExercise.getInstructions())
            self.currentGoalLabel.setText(self.currentExercise.getGoal())
        else:
            self.currentExercise = chordFinder(level)
            self.instructionsLabel.setText(self.currentExercise.getInstructions())
            self.currentGoalLabel.setText(self.currentExercise.getGoal())

    def volumeChanged(self):
        #self.globalVolume = self.volumeSlider.value() / 100.0
        #print("new gVol: " + str(self.globalVolume))
        vol = self.volumeSlider.value() / 100.0
        self.clickSound.set_volume(vol)

    def metroDialChanged(self):
        self.metroBpmLabel.setText("BPM: " + str(self.metroBpmDial.value()))

    def metroClicked(self):
        self.metroLabel.setText("button pressed!")
        print("current bpm: " + str(self.metroBpmDial.value()))
        msDelay = int(60000.0/self.metroBpmDial.value())
        print("ms wait: " + str(msDelay))

        if self.metroIsPlaying == True:
            self.metroIsPlaying = False
            self.metroTimer.stop()
            self.metroLabel.setText("metronome off")
        else:
            self.metroIsPlaying = True
            self.metroTimer.start(msDelay)
            self.clickSound.play()
            self.metroLabel.setText("metronome on")

    def metroTimeout(self):
        msDelay = int(60000.0/self.metroBpmDial.value())
        self.metroTimer.start(msDelay)
        self.clickSound.play()

    def reportNote(self, note):
        self.TunerNote.setText("Note: " + str(note))

        if self.currentExercise != 0:
            if self.currentExercise.evaluateNote(note):
                self.instructionsLabel.setText(self.currentExercise.getInstructions())
                self.currentGoalLabel.setText(self.currentExercise.getGoal())

if __name__ == "__main__":
    import sys

    #pygame.init()
    mixer.init()

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
